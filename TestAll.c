#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     beacon,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     compass,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     blocks,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     left,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    left_finger,          tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    right_finger,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    autoBlockServo,       tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ===========================================================
// Procedure/Function/Task interfaces definitions
// ===========================================================
void EncoderDrive(long _distTrav);
void EncoderTurn(int speed, int degrees, bool turnRight);
// ===========================================================
// Globals
// ===========================================================
//bool g_BeaconFound = false;
int g_Speed = 0;
//int g_TurnSpeed = 30;
int g_MotorOffset = 0;
int g_MotorOffsetHeading = 0;

// clicks / inch = 154.83
// inches / click =
const float ClicksPerInch = 41.6667;
// inch / degree = .1196
//float InchPerDegree = .142;
float InchPerDegree = .35;//more turns more
const float InchPerDegreeLeftTurn = .35;//more turns more

task main(){
	// moving forward
	//EncoderDrive(5, 5, 5, -5);

	// turning by degrees
	nMotorEncoder[right] = 0;
	nMotorEncoder[left] = 0;

	while(true){
		nxtDisplayTextLine(0, "Compass= %1.0f", SensorValue[compass]);

		nxtDisplayTextLine(1, "Beacon = %1.0f", SensorValue[beacon]);

		nxtDisplayTextLine(2, "Sonar = %1.2f", SensorValue[sonar]);

		nxtDisplayTextLine(3, "Right Enc=%1f", nMotorEncoder[right]);

		nxtDisplayTextLine(4, "Left Enc=%1f", nMotorEncoder[left]);

		nxtDisplayTextLine(5, "BlkArm Enc=%1f", nMotorEncoder[blocks]);

		//EncoderDrive(500);

		//wait10Msec(10);

		//EncoderTurn(10,90,true );

		motor[right] = g_Speed;
		motor[left] = g_Speed + g_MotorOffsetHeading;

//		motor[flag] = -20;
	}

}


//============================================================================
//=== EncoderDrive
//============================================================================
void EncoderDrive(long _distTrav){
	// clicks must be divided by the clicks/inch
	//float distrightInches = dist/ClicksPerInch;
	//float distleftInches = dist/ClicksPerInch;

	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
	if (_distTrav > 0) {
		while(abs(nMotorEncoder[left]) <= _distTrav && abs(nMotorEncoder[right]) <= _distTrav) {
	  	motor[right] = g_Speed;
			motor[left] = g_Speed + g_MotorOffset;
			//nxtDisplayTextLine(2, "%Left = 1.2f", nMotorEncoder[left]);
			//nxtDisplayTextLine(3, "%Righ = 1.2f", nMotorEncoder[right]);
		}
	} else {
		while(abs(nMotorEncoder[left]) <= abs(_distTrav) && abs(nMotorEncoder[right]) <= abs(_distTrav)) {
	  	motor[right] = -g_Speed;
			motor[left] = -(g_Speed + g_MotorOffset);
			//nxtDisplayTextLine(2, "%Left = 1.2f", nMotorEncoder[left]);
			//nxtDisplayTextLine(3, "%Righ = 1.2f", nMotorEncoder[right]);
		}
	}
	nxtDisplayTextLine(2, "Success!");
	motor[right] = 0;
	motor[left] = 0;
}

//============================================================================
//=== EncoderTurn
//============================================================================
// turns the robot base on degrees given
void EncoderTurn(int speed, int degrees, bool turnRight){
	int turnFactor;
	if(turnRight){
		turnFactor = -1;
	}else{
		turnFactor = 1;
		InchPerDegree = InchPerDegreeLeftTurn;
	}

	float distInches = abs(degrees) * InchPerDegree;
	float distClicks = distInches * ClicksPerInch;

	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;

	eraseDisplay();

	//while(abs(nMotorEncoder[left]) <= distClicks && abs(nMotorEncoder[right]) <= distClicks) {
  while(abs(nMotorEncoder[left]) <= distClicks) {
  	motor[right] = speed*turnFactor;
		motor[left] = -speed*turnFactor;
		nxtDisplayTextLine(2, "LeftEn= %1.0f", abs(nMotorEncoder[left]));
		nxtDisplayTextLine(3, "RightEn= %1.0f", abs(nMotorEncoder[right]));
		nxtDisplayTextLine(4, "distClicks= %1.2f", distClicks);
	}
	motor[right] = 0;
	motor[left] = 0;
	//nxtDisplayTextLine(2, "LeftEn= %1.0f", nMotorEncoder[left]);
	//nxtDisplayTextLine(3, "RightEn= %1.0f", nMotorEncoder[right]);
	//nxtDisplayTextLine(4, "distClicks= %1.2f", distClicks);
}
