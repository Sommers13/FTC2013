#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     beacon,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     compass,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     blocks,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     left,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,      ,             tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    left_finger,          tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    right_finger,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    autoBlockServo,       tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    ,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"//needed for waitForStart()

// ------------------------------------------------------------
// REMMEMBER! This is for LEFT!!!!!!!!!!!!!!!!!!

#define Wall_Follow_Distance 35
#define See_Wall_Min 0
#define See_Wall_Max 60
#define WallFollow_Correction_Factor 1
#define HeadingCorrection -18

#define Beacon_Stop_Correction 0
#define Drive_To_First_Turn 800
#define First_Turn 75
#define Drive_To_Second_Turn -2300
#define Second_Turn 50
#define Drive_To_Third_Turn -2500
#define Third_turn 90
#define Drive_Up_Ramp -5000

#define AUTO_ARM_START 169
#define AUTO_ARM_TARGET 40
#define AUTO_ARM_END 80
#define AUTO_ARM_SPEED 255

#define RIGHT_FINGER_CLOSED (30)
#define LEFT_FINGER_CLOSED (220)

// ===========================================================
// Procedure/Function/Task interfaces definitions
// ===========================================================
void BlockPlacement();
void DriveUntilBeacon();
void EncoderDrive(long _distTrav);
void EncoderTurn(int speed, int degrees, bool turnRight);
void DriveUntilEndOfWall(int _Direction, float _desiredheading);
void TurnToHeading(float _desiredheading);
task MovingAvgSonar();

// ===========================================================
// Globals
// ===========================================================
bool g_BeaconFound = false;
int g_Speed = -30;
int g_TurnSpeed = 20;
int g_MotorOffset = 0;
int g_MotorOffsetHeading =1;
//int g_MotorOffsetFactor = .175;
float g_Sonar1;
float g_stdDevSonar1;

// clicks / inch = 154.83
// inches / click =
const float ClicksPerInch = 41.6667;
// inch / degree = .1196
//float InchPerDegree = .142;
float InchPerDegree = .35;//more turns more
const float InchPerDegreeLeftTurn = .35;//more turns more

//============================================================================
//== task main
//============================================================================
task main(){
	servoChangeRate[autoBlockServo] = 0;
	for(int i=0;i<50;i++)
	{
		servo[autoBlockServo] = AUTO_ARM_START;
		servo[right_finger] = RIGHT_FINGER_CLOSED;
		servo[left_finger] = LEFT_FINGER_CLOSED;
		wait1Msec(5);
	}
	servoChangeRate[autoBlockServo] = AUTO_ARM_SPEED;

	// Find heading
	float desiredheading = 0;
  for (int i=0; i<10; i++) {
  	desiredheading += SensorValue[compass];
  	wait1Msec(100);
  }
  desiredheading /= 10;

  // ** WAIT FOR START *******************************************************
	waitForStart();
  // ** WAIT FOR START *******************************************************

	// Zero out encoders at start
	nMotorEncoder[right] = 0;
	nMotorEncoder[left] = 0;

	StartTask(MovingAvgSonar);

	DriveUntilBeacon();

	wait1Msec(200);

	//PlaySound(soundBeepBeep);

	//while(true);

	// Beacon_Stop_Correction
	EncoderDrive(Beacon_Stop_Correction);

	wait1Msec(200);

	//while(true);

	BlockPlacement();

//	TurnToHeading(desiredheading);

	// Drive back until end of wall
	DriveUntilEndOfWall(-1, desiredheading);

	//while(true);

	wait1Msec(200);

	//PlaySound(soundBeepBeep);

	//nxtDisplayTextLine(2, "Sonar = %1.0f", SensorValue[sonar]);

	// drive a bit back
	EncoderDrive(Drive_To_First_Turn);

	//while(true);

	wait1Msec(200);

	//PlaySound(soundBeepBeep);

	// first turn tward ramp
 	EncoderTurn(-g_TurnSpeed, First_Turn, true);

 	//while(true);

 	wait1Msec(200);

	//PlaySound(soundBeepBeep);

	// drive a bit
 	EncoderDrive(Drive_To_Second_Turn);

 	wait1Msec(200);

	//PlaySound(soundBeepBeep);

	// second turn tward ramp
 	EncoderTurn(-g_TurnSpeed, Second_Turn, true);

 	wait1Msec(200);

 	// drive a bit
 	EncoderDrive(Drive_To_Third_Turn);

	//PlaySound(soundBeepBeep);

	// turn to face ramp
 	EncoderTurn(-g_TurnSpeed, Third_turn, true);

 	wait1Msec(200);

	//PlaySound(soundBeepBeep);
//while(true);
	// Get on ramp

	//while(true);
  g_Speed = 80;
 	EncoderDrive(Drive_Up_Ramp);

	//PlaySound(soundBeepBeep);
}
//============================================================================
//=== MovingAvgSonar - calc moving avg and std dev for both sonar sensors
//============================================================================
task MovingAvgSonar() {
	float numberOfAvgs = 10; // number of averages to take
	float rawSonar1 = 0;
	float sumSonar1 = 0;
	float sumSquaresSonar1 = 0;
	int countPings = 0;
	float Sonar1 = 0;

	while(true)	{
		rawSonar1 = SensorValue[sonar];

		// sum of the raw values
		sumSonar1 = sumSonar1 + rawSonar1;

		// sum of the squares
		sumSquaresSonar1 = sumSquaresSonar1 + pow(rawSonar1, 2); // sum the squares of the raws

		countPings = countPings + 1;

		if(countPings == numberOfAvgs){
			// get avg distance reading before we sqr it
	    Sonar1 = sumSonar1 / numberOfAvgs;

	    // square the sum
	    sumSonar1 = pow(sumSonar1,2);

	    // Calc std dev
	    g_stdDevSonar1 = ( sumSquaresSonar1 - (sumSonar1 / numberOfAvgs) )/ (numberOfAvgs - 1);

	    if (g_stdDevSonar1 > .8){
	    	g_Sonar1 = g_Sonar1; // dont use new value
	  	} else {
				g_Sonar1 = Sonar1;
			}

	    // reset
	    countPings = 0;
	    sumSonar1 = 0;
	    sumSquaresSonar1 = 0;

	    //wait1Msec(20);
	  }

		//nxtDisplayTextLine(0, "StdDev = %1.2f", g_stdDevSonar1);
//		nxtDisplayTextLine(1, "S2raw = %1.2f", rawSonar2);

		wait1Msec(20);
	}
}

//============================================================================
//=== TurnToHeading
//============================================================================

void TurnToHeading(float _desiredheading) {
		for (int j=0; j<50; j++) {
			float heading = 0;
		  for (int i=0; i<4; i++) {
		  	heading += SensorValue[compass];
		  	wait1Msec(11);
		  }
		  heading /= 4;

		  int error = _desiredheading - heading;

		  //Fix error if there is roll-over at 360
		  if (abs(error) >= 20){
		    if (error < -180) error += 360;
		    else if (error > 180) error -= 360;
		  }

		  motor[right] =  1.2*error;
		  motor[left] = -1.2*error + g_MotorOffsetHeading;

			nxtDisplayTextLine(2, "Hd Err = %1.0f", error);

			nxtDisplayTextLine(3, "i = %1.0f", j);

		  wait1Msec(10);
		}
}

//============================================================================
//=== DriveUntilEndOfWall
//============================================================================
// Drive until the beacon is found
void DriveUntilEndOfWall(int _Direction, float _desiredheading) {
	bool endOfWall = false;
	int sonarValue = SensorValue[sonar];
	int PingMin = 255;
	int PingMax = 0;
	int WallError = 0;

	while(!endOfWall) {

		//while(g_stdDevSonar1 > 1);

		sonarValue = g_Sonar1;

		if(PingMin > sonarValue)
	  	PingMin = sonarValue;

	  if(PingMax < sonarValue)
	  	PingMax = sonarValue;

		nxtDisplayTextLine(0, "Sonar = %1.0f", sonarValue);
		//nxtDisplayTextLine(2, "S min = %1.0f", PingMin);
		nxtDisplayTextLine(2, "S max = %1.0f", PingMax);

		// Look For End Of Wall
		if(sonarValue > 200){
			WallError = 0;
			endOfWall = true;
		}

		// BEGIN Follow heading
		float heading = 0;
	  for (int i=0; i<4; i++) {
	  	heading += SensorValue[compass];
	  	wait1Msec(11);
	  }
	  heading /= 4;

	  int error = _desiredheading + HeadingCorrection - heading;

	  //error = 0;

	  //Fix error if there is roll-over at 360
	  if (abs(error) >= 20){
	    if (error < -180) error += 360;
	    else if (error > 180) error -= 360;
	  }

	  motor[right] = -g_Speed + error;
	  motor[left] = -g_Speed - error - g_MotorOffset;
		// END Follow Heading
	}

	// Slow to stop
	//for (int i=g_Speed; i!=0; i++) {
	//	motor[right] = -i;
	//	motor[left] = -i - i*g_MotorOffsetFactor;
	//	wait1Msec(10);
	//}
	motor[right]=0;
	motor[left]=0;
}

//============================================================================
//=== DriveUntilBeacon
//============================================================================
// Drive until the beacon is found
void DriveUntilBeacon() {
	int WallError = 0;
	bool sonarASeesWall = false;
	float sonarValueA = 0;

	while(!g_BeaconFound) {
		//sonarValueA = 0;
	 // for (int i=0; i<4; i++) {
	 // 	sonarValueA += SensorValue[sonar];
	 // 	wait1Msec(11);
	 // }
	 // sonarValueA /= 4;

		//while(g_stdDevSonar1 > 5);

		sonarValueA = g_Sonar1;

		nxtDisplayTextLine(2, "Sonar = %1.0f", sonarValueA);

		if(sonarValueA > See_Wall_Min && sonarValueA < See_Wall_Max){
			WallError = Wall_Follow_Distance - sonarValueA;
		}else{
			WallError = 0;
			//PlaySound(soundBeepBeep);
		}

		//WallError=0;

		motor[right] = g_Speed + (WallFollow_Correction_Factor * WallError);
		motor[left] = g_Speed + g_MotorOffset - (WallFollow_Correction_Factor * WallError);

		int beaconValue = SensorValue[beacon];
	  nxtDisplayTextLine(1, "Beacon = %1.0f", beaconValue);

		if(beaconValue == 5) g_BeaconFound = true;
	}
	motor[right] = 0;
	motor[left] = 0;
}

//============================================================================
//=== BlockPlacement
//============================================================================
void BlockPlacement(){
	//g_BlockPlaced = true;
	servo[autoBlockServo] = AUTO_ARM_TARGET;
	wait1Msec(500);
	servo[autoBlockServo] = AUTO_ARM_END;
	wait1Msec(500);
	//servo[autoBlockServo] = AUTO_ARM_START;
	//wait1Msec(500);
	//PlaySound(soundBeepBeep);

	//g_DistanceTraveled = (nMotorEncoder[right]);
}

//============================================================================
//=== EncoderDrive
//============================================================================
void EncoderDrive(long _distTrav){
	// clicks must be divided by the clicks/inch
	//float distrightInches = dist/ClicksPerInch;
	//float distleftInches = dist/ClicksPerInch;

	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
	if (_distTrav > 0) {
		while(abs(nMotorEncoder[left]) <= _distTrav && abs(nMotorEncoder[right]) <= _distTrav) {
	  	motor[right] = g_Speed;
			motor[left] = g_Speed + g_MotorOffset;
			//nxtDisplayTextLine(2, "%Left = 1.2f", nMotorEncoder[left]);
			//nxtDisplayTextLine(3, "%Righ = 1.2f", nMotorEncoder[right]);
		}
	} else {
		while(abs(nMotorEncoder[left]) <= abs(_distTrav) && abs(nMotorEncoder[right]) <= abs(_distTrav)) {
	  	motor[right] = -g_Speed;
			motor[left] = -(g_Speed + g_MotorOffset);
			//nxtDisplayTextLine(2, "%Left = 1.2f", nMotorEncoder[left]);
			//nxtDisplayTextLine(3, "%Righ = 1.2f", nMotorEncoder[right]);
		}
	}
	nxtDisplayTextLine(2, "Success!");
	motor[right] = 0;
	motor[left] = 0;
}

//============================================================================
//=== EncoderTurn
//============================================================================
// turns the robot base on degrees given
void EncoderTurn(int speed, int degrees, bool turnRight){
	int turnFactor;
	if(turnRight){
		turnFactor = -1;
	}else{
		turnFactor = 1;
		InchPerDegree = InchPerDegreeLeftTurn;
	}

	float distInches = abs(degrees) * InchPerDegree;
	float distClicks = distInches * ClicksPerInch;

	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;

	eraseDisplay();

	//while(abs(nMotorEncoder[left]) <= distClicks && abs(nMotorEncoder[right]) <= distClicks) {
  while(abs(nMotorEncoder[left]) <= distClicks) {
  	motor[right] = speed*turnFactor;
		motor[left] = -speed*turnFactor;
		nxtDisplayTextLine(2, "LeftEn= %1.0f", abs(nMotorEncoder[left]));
		nxtDisplayTextLine(3, "RightEn= %1.0f", abs(nMotorEncoder[right]));
		nxtDisplayTextLine(4, "distClicks= %1.2f", distClicks);
	}
	motor[right] = 0;
	motor[left] = 0;
	//nxtDisplayTextLine(2, "LeftEn= %1.0f", nMotorEncoder[left]);
	//nxtDisplayTextLine(3, "RightEn= %1.0f", nMotorEncoder[right]);
	//nxtDisplayTextLine(4, "distClicks= %1.2f", distClicks);
}
