#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     beacon,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     blocks,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     left,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    left_finger,          tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    right_finger,         tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    autoBlockServo,       tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    block_eject,               tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define UP (490)
#define HORIZ_BACK (0)
#define HORIZ_FRONT (1000)
#define DOWN (1450)
#define autoBlockServo_ARM (80)
#define autoBlockServo_ARM_SPEED (30)
#define FLAG_ARM_SPEED (255)

#define RIGHT_FINGER_OPEN (0)
#define RIGHT_FINGER_CLOSED (30)

#define LEFT_FINGER_OPEN (255)
#define LEFT_FINGER_CLOSED (220)

#define BLOCK_EJECT_OPEN (40)
#define BLOCK_EJECT_CLOSED (2)

#define FINGER_SPEED (255)
#define cJoyDead (5) // joystick range considered centered
#define cMotorMin (7) // minimum drive motor power
#define cDriveExp (2) // exponent for drive power calculations  (1 = linear, 2 = squared)
// note: cDriveExp must be 1 or 2 or any value between 1 and 2
bool IsSetAntiGrav = false;
long AntiGrav = 0;

#include "JoystickDriver.c"

int expDrive(int joyVal, float driveExp, int joyDead, int motorMin);
int expDriveBLOCK(int joyVal, float driveExp, int joyDead, int motorMin);
//float lastEncoder=0;

task main(){
	servoChangeRate[autoBlockServo] = 10;
	for(int i=0;i<30;i++){
		servo[right_finger] = RIGHT_FINGER_OPEN;
		servo[left_finger] = LEFT_FINGER_OPEN;
		servo[block_eject] = BLOCK_EJECT_CLOSED;
		servo[autoBlockServo] = 80;

		wait1Msec(5);
	}
	servoChangeRate[autoBlockServo] = 0;

	bool lf = false;
	bool rf = false;
	bool lf_first_press = true;
	bool rf_first_press = true;
	nMotorEncoder[blocks] = 0;

	waitForStart();

	while(true)	{
		// get joystick values
		getJoystickSettings(joystick);
		nxtDisplayTextLine(4, "Enco: %d", nMotorEncoder[blocks]);

		/*
		// Send RIGHT joystick input to drive motors
		motor[right] =  expDrive(joystick.joy1_y2, cDriveExp, cJoyDead, cMotorMin)
			+ expDrive(joystick.joy1_x2, cDriveExp, cJoyDead, cMotorMin);
	 	motor[left] = expDrive(joystick.joy1_y2, cDriveExp, cJoyDead, cMotorMin)
			- expDrive(joystick.joy1_x2, cDriveExp, cJoyDead, cMotorMin);
		*/

		motor[left] = expDrive(joystick.joy1_y2, cDriveExp, cJoyDead, cMotorMin);
		motor[right] = expDrive(joystick.joy1_y1, cDriveExp, cJoyDead, cMotorMin);

		// Use Trigger buttons to raise/lower Bar-Hang arm
		motor[lift] = (joy2Btn(5) || joy2Btn(6)) ? (joy2Btn(5) ? 95 : -95) : 0;

		// Use Trigger buttons to raise/lower flag
		motor[flag] = (joy2Btn(7) || joy2Btn(8)) ? (joy2Btn(7) ? 95 : -95) : 0;

		// Control Flag raising motor
		//servo[flag] = joystick.joy2_y2+128;

		// =========================================================
		// Block Lifting ===========================================
		float userSpeedRequired = joystick.joy2_y1;

		// keep user from driving arm into bot
		if((userSpeedRequired < 0) && (nMotorEncoder[blocks] <= -4870) && !joy2Btn(4))
			userSpeedRequired = 0;
		else if((userSpeedRequired > 0) && (nMotorEncoder[blocks] >= 20) && !joy2Btn(4))
			userSpeedRequired = 0;

		motor[blocks] =  expDriveBLOCK(userSpeedRequired/2, 1, cJoyDead, cMotorMin);

		// Reseting encoder
		if(joy2Btn(4) && joy2Btn(2)){
			nMotorEncoder[blocks] = 0;
		}

		// Block Lifting end ======================================
		// ========================================================

		//autoBlockServo Arm (autoBlockArm) - Keep out of way of Black Arm
		servo[autoBlockServo] = autoBlockServo_ARM;

		//Left finger
		if(joy2Btn(1)){
			if(lf_first_press){
				lf = !lf;
			}
			lf_first_press = false;
		}
		else{
			lf_first_press = true;
		}

		// Close Fingers when putting arm away
		if(lf || nMotorEncoder[blocks] > -700){
			servo[left_finger] = LEFT_FINGER_CLOSED;
		}
		else{
			servo[left_finger] = LEFT_FINGER_OPEN;
		}

		//Right finger
		if(joy2Btn(3)){
			if(rf_first_press){
				rf = !rf;
			}
			rf_first_press = false;
		}
		else{
			rf_first_press = true;
		}

		// Close Fingers when putting arm away
		if(rf || nMotorEncoder[blocks] > -700){
			servo[right_finger] = RIGHT_FINGER_CLOSED;
		}
		else{
			servo[right_finger] = RIGHT_FINGER_OPEN;
		}

		// Block Eject Servo
		if(joystick.joy2_y2 > 50){
			servo[block_eject] = BLOCK_EJECT_OPEN;
		} else {
			servo[block_eject] = BLOCK_EJECT_CLOSED;
		}
	}
}

// turns liner input into an exponential curve as output
int expDrive(int joyVal, float driveExp, int joyDead, int motorMin){
	int joyMax = 128 - joyDead;
	int joySign = sgn(joyVal);
	int joyLive = abs(joyVal) - joyDead;
	if (joyLive <= joyDead){
		return 0;
	}
	else {
		return joySign * (motorMin + ((100 - motorMin) * pow(joyLive, driveExp) / pow(joyMax, driveExp)));
	}
}

// SPECIAL EXPDRIVE FOR BLOCK PLACING ARM
int expDriveBLOCK(int joyVal, float driveExp, int joyDead, int motorMin){
	long GravError=0;
	int joyMax = 128 - joyDead;
	int joySign = sgn(joyVal);
	int joyLive = abs(joyVal) - joyDead;
	if (joyLive <= joyDead){
		// When the arm is drooping, go back up
		if(IsSetAntiGrav == false){
			AntiGrav = nMotorEncoder[blocks];
			IsSetAntiGrav = true;
		}
		if(IsSetAntiGrav == true){
			GravError = AntiGrav - nMotorEncoder[blocks];
			nxtDisplayTextLine(2, "Encoder: %d", nMotorEncoder[blocks]);
			nxtDisplayTextLine(3, "GravError: %d", GravError);
			//motor[blocks] = -GravError/2;
		}
		return GravError/20;
	}
	else {
		IsSetAntiGrav = false;
		return joySign * (motorMin + ((100 - motorMin) * pow(joyLive, driveExp) / pow(joyMax, driveExp)));
	}
}
